#[std]


type Test(1) {
    fn new(n: num) -> Test {
        return n as Test;
    }

    fn item(self: &Test) -> &num { return self as &num }

    // No copy or drop methods are defined, so `Test`
    // can't possibly manage memory.
}

fn test() -> Test {
    return Test::new(1);
}

fn main() {
    // Okay!
    let t = test();
    putnumln(t->item);

    // Okay!
    putnumln(test()->item);
}